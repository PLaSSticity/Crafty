<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>TinySTM: stm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TinySTM
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stm.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>STM functions.  
<a href="#details">More...</a></p>

<p><a href="stm_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionstm__tx__attr.html">stm_tx_attr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction attributes specified by the application.  <a href="unionstm__tx__attr.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adcbb6b78475bb3c13e4b6565ad2a2eb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbb6b78475bb3c13e4b6565ad2a2eb1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#adcbb6b78475bb3c13e4b6565ad2a2eb1">STM_VERSION</a>&#160;&#160;&#160;&quot;1.0.4&quot;</td></tr>
<tr class="memdesc:adcbb6b78475bb3c13e4b6565ad2a2eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version string. <br/></td></tr>
<tr class="memitem:a00c7d86533508752aabd69bc9e89c62f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c7d86533508752aabd69bc9e89c62f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a00c7d86533508752aabd69bc9e89c62f">STM_VERSION_NB</a>&#160;&#160;&#160;104</td></tr>
<tr class="memdesc:a00c7d86533508752aabd69bc9e89c62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version number (times 100) <br/></td></tr>
<tr class="memitem:ac697e15fca176fa239e08d63fcc79694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac697e15fca176fa239e08d63fcc79694"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac697e15fca176fa239e08d63fcc79694">_CALLCONV</a></td></tr>
<tr class="memdesc:ac697e15fca176fa239e08d63fcc79694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling convention. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a571736ccf3baeb79b32e66efd03f2ff0"><td class="memItemLeft" align="right" valign="top">typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a></td></tr>
<tr class="memdesc:a571736ccf3baeb79b32e66efd03f2ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a word (accessible atomically) on the target architecture.  <a href="#a571736ccf3baeb79b32e66efd03f2ff0"></a><br/></td></tr>
<tr class="memitem:ac9ce435b82936240375ce9e71c27b5db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9ce435b82936240375ce9e71c27b5db"></a>
typedef union <a class="el" href="unionstm__tx__attr.html">stm_tx_attr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a></td></tr>
<tr class="memdesc:ac9ce435b82936240375ce9e71c27b5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction attributes specified by the application. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba33be1ca54eecc0cc8c593d09ed6efbae">STM_PATH_INSTRUMENTED</a> =  0x01, 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba450b54286a2b90acdc9778335990ccec">STM_PATH_UNINSTRUMENTED</a> =  0x02, 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba7b61a76a11fbf84128a391a9b0cef327">STM_ABORT_EXPLICIT</a> =  (1 &lt;&lt; 5), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba6c9347782cf0b1d6fea89bc723148551">STM_ABORT_NO_RETRY</a> =  (1 &lt;&lt; 5) | (0x01 &lt;&lt; 8), 
<br/>
&#160;&#160;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba75d0311e7a4ddd3064164e4642d0fa95">STM_ABORT_IMPLICIT</a> =  (1 &lt;&lt; 6), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba46eaf37a2b51b4db497304a3e8869973">STM_ABORT_RR_CONFLICT</a> =  (1 &lt;&lt; 6) | (0x01 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baa0ab09921c0090164a7d6aa2538cac17">STM_ABORT_RW_CONFLICT</a> =  (1 &lt;&lt; 6) | (0x02 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4e7abf037faa563495f6fa5da509219c">STM_ABORT_WR_CONFLICT</a> =  (1 &lt;&lt; 6) | (0x03 &lt;&lt; 8), 
<br/>
&#160;&#160;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4d97b7b8272d8d7683ab5a0ffe9c25e7">STM_ABORT_WW_CONFLICT</a> =  (1 &lt;&lt; 6) | (0x04 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baa705d4540e95c9b214d2dbbebeb7dbe3">STM_ABORT_VAL_READ</a> =  (1 &lt;&lt; 6) | (0x05 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba30a4997234b15d65d38e27db17f3e93c">STM_ABORT_VAL_WRITE</a> =  (1 &lt;&lt; 6) | (0x06 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55badb805d9ecf362fe018eeacb14bc7c73e">STM_ABORT_VALIDATE</a> =  (1 &lt;&lt; 6) | (0x07 &lt;&lt; 8), 
<br/>
&#160;&#160;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f6e471602d10189a79ca90ffd4d11e2">STM_ABORT_IRREVOCABLE</a> =  (1 &lt;&lt; 6) | (0x09 &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baeb8c86645eef38a461e9ff85c3807c3e">STM_ABORT_KILLED</a> =  (1 &lt;&lt; 6) | (0x0A &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba840c7cb44183d525c2a308071f486670">STM_ABORT_SIGNAL</a> =  (1 &lt;&lt; 6) | (0x0B &lt;&lt; 8), 
<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba7b4d1c74aa13aca00f07158f5f3b2091">STM_ABORT_EXTEND_WS</a> =  (1 &lt;&lt; 6) | (0x0C &lt;&lt; 8), 
<br/>
&#160;&#160;<a class="el" href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba886ebf1c55e78174f2734cf34e699608">STM_ABORT_OTHER</a> =  (1 &lt;&lt; 6) | (0x0F &lt;&lt; 8)
<br/>
 }</td></tr>
<tr class="memdesc:a06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reason for aborting (returned by sigsetjmp() upon transaction restart).  <a href="stm_8h.html#a06fc87d81c62e9abb8790b6e5713c55b">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab934371cd3a4ccff13196df52d118c1d"><td class="memItemLeft" align="right" valign="top">struct stm_tx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ab934371cd3a4ccff13196df52d118c1d">stm_current_tx</a> (void)</td></tr>
<tr class="memdesc:ab934371cd3a4ccff13196df52d118c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current transaction descriptor.  <a href="#ab934371cd3a4ccff13196df52d118c1d"></a><br/></td></tr>
<tr class="memitem:a91d8723fd14f8f23f6231f43e5fb0d07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a91d8723fd14f8f23f6231f43e5fb0d07">stm_init</a> (void)</td></tr>
<tr class="memdesc:a91d8723fd14f8f23f6231f43e5fb0d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the STM library.  <a href="#a91d8723fd14f8f23f6231f43e5fb0d07"></a><br/></td></tr>
<tr class="memitem:a67285bbeb06819a4f053207e71ff4995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a67285bbeb06819a4f053207e71ff4995">stm_exit</a> (void)</td></tr>
<tr class="memdesc:a67285bbeb06819a4f053207e71ff4995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the STM library.  <a href="#a67285bbeb06819a4f053207e71ff4995"></a><br/></td></tr>
<tr class="memitem:a7b7d6f423cd3ff074f5c83926fd37439"><td class="memItemLeft" align="right" valign="top">struct stm_tx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a7b7d6f423cd3ff074f5c83926fd37439">stm_init_thread</a> (void)</td></tr>
<tr class="memdesc:a7b7d6f423cd3ff074f5c83926fd37439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a transactional thread.  <a href="#a7b7d6f423cd3ff074f5c83926fd37439"></a><br/></td></tr>
<tr class="memitem:aac7f1c4dd5f948f23a2f4df0a7d530d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aac7f1c4dd5f948f23a2f4df0a7d530d6">stm_get_parameter</a> (const char *name, void *val)</td></tr>
<tr class="memdesc:aac7f1c4dd5f948f23a2f4df0a7d530d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get various parameters of the STM library.  <a href="#aac7f1c4dd5f948f23a2f4df0a7d530d6"></a><br/></td></tr>
<tr class="memitem:abca06bb60ae936118c769f6fdd41530c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#abca06bb60ae936118c769f6fdd41530c">stm_set_parameter</a> (const char *name, void *val)</td></tr>
<tr class="memdesc:abca06bb60ae936118c769f6fdd41530c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set various parameters of the STM library.  <a href="#abca06bb60ae936118c769f6fdd41530c"></a><br/></td></tr>
<tr class="memitem:a4f1e7f7261639257cc8e572cca9010af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a4f1e7f7261639257cc8e572cca9010af">stm_create_specific</a> (void)</td></tr>
<tr class="memdesc:a4f1e7f7261639257cc8e572cca9010af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key to associate application-specific data to the current thread/transaction.  <a href="#a4f1e7f7261639257cc8e572cca9010af"></a><br/></td></tr>
<tr class="memitem:ac8b66dbadfd62e541409823d1b80aba7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac8b66dbadfd62e541409823d1b80aba7">stm_get_specific</a> (int key)</td></tr>
<tr class="memdesc:ac8b66dbadfd62e541409823d1b80aba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get application-specific data associated to the current thread/transaction and a given key.  <a href="#ac8b66dbadfd62e541409823d1b80aba7"></a><br/></td></tr>
<tr class="memitem:acf336ae279fd83cf1195bd76aea01df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#acf336ae279fd83cf1195bd76aea01df7">stm_set_specific</a> (int key, void *data)</td></tr>
<tr class="memdesc:acf336ae279fd83cf1195bd76aea01df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set application-specific data associated to the current thread/transaction and a given key.  <a href="#acf336ae279fd83cf1195bd76aea01df7"></a><br/></td></tr>
<tr class="memitem:a7f2aabd7cc97f9a1a340b57aec57fb2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a7f2aabd7cc97f9a1a340b57aec57fb2c">stm_register</a> (void(*on_thread_init)(void *arg), void(*on_thread_exit)(void *arg), void(*on_start)(void *arg), void(*on_precommit)(void *arg), void(*on_commit)(void *arg), void(*on_abort)(void *arg), void *arg)</td></tr>
<tr class="memdesc:a7f2aabd7cc97f9a1a340b57aec57fb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register application-specific callbacks that are triggered each time particular events occur.  <a href="#a7f2aabd7cc97f9a1a340b57aec57fb2c"></a><br/></td></tr>
<tr class="memitem:ac932e2cd9b2b1621326d281329362bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac932e2cd9b2b1621326d281329362bfc">stm_unit_load</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr class="memdesc:ac932e2cd9b2b1621326d281329362bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction-safe load.  <a href="#ac932e2cd9b2b1621326d281329362bfc"></a><br/></td></tr>
<tr class="memitem:aec9492eba41d0df151c30fc559a14957"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aec9492eba41d0df151c30fc559a14957">stm_unit_store</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr class="memdesc:aec9492eba41d0df151c30fc559a14957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction-safe store.  <a href="#aec9492eba41d0df151c30fc559a14957"></a><br/></td></tr>
<tr class="memitem:a328faa38ec6bf579ba6fd166765a7527"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a328faa38ec6bf579ba6fd166765a7527">stm_unit_store2</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr class="memdesc:a328faa38ec6bf579ba6fd166765a7527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction-safe store.  <a href="#a328faa38ec6bf579ba6fd166765a7527"></a><br/></td></tr>
<tr class="memitem:ac94022bd1deed2614d953fa4110bb452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac94022bd1deed2614d953fa4110bb452">stm_get_clock</a> (void)</td></tr>
<tr class="memdesc:ac94022bd1deed2614d953fa4110bb452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the global clock (used for timestamps).  <a href="#ac94022bd1deed2614d953fa4110bb452"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a946305e1b65d3d7eb26c6573a00b7f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a946305e1b65d3d7eb26c6573a00b7f8b">stm_exit_thread</a> (void)</td></tr>
<tr class="memdesc:a946305e1b65d3d7eb26c6573a00b7f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up a transactional thread.  <a href="#a946305e1b65d3d7eb26c6573a00b7f8b"></a><br/></td></tr>
<tr class="memitem:ad039146726ea5765cab933a42a7c8bdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad039146726ea5765cab933a42a7c8bdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stm_exit_thread_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae984594f360cba2ac5c2abd8875eb0a0"><td class="memItemLeft" align="right" valign="top">sigjmp_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ae984594f360cba2ac5c2abd8875eb0a0">stm_start</a> (<a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a> attr)</td></tr>
<tr class="memdesc:ae984594f360cba2ac5c2abd8875eb0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a transaction.  <a href="#ae984594f360cba2ac5c2abd8875eb0a0"></a><br/></td></tr>
<tr class="memitem:ac9d8461c9e1943ed6b50776f7c442726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d8461c9e1943ed6b50776f7c442726"></a>
sigjmp_buf *&#160;</td><td class="memItemRight" valign="bottom"><b>stm_start_tx</b> (struct stm_tx *tx, <a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a> attr)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a34a2ee9e8d2a85b7876580b388c8f274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a34a2ee9e8d2a85b7876580b388c8f274">stm_commit</a> (void)</td></tr>
<tr class="memdesc:a34a2ee9e8d2a85b7876580b388c8f274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to commit a transaction.  <a href="#a34a2ee9e8d2a85b7876580b388c8f274"></a><br/></td></tr>
<tr class="memitem:a47f1f1d18c28baec0860e1056bb53987"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47f1f1d18c28baec0860e1056bb53987"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stm_commit_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a689d0e2f43d0c823699cd8255ad7bd8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a689d0e2f43d0c823699cd8255ad7bd8d">stm_abort</a> (int abort_reason)</td></tr>
<tr class="memdesc:a689d0e2f43d0c823699cd8255ad7bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly abort a transaction.  <a href="#a689d0e2f43d0c823699cd8255ad7bd8d"></a><br/></td></tr>
<tr class="memitem:a04d2171c8cabc817a4f2302905fcd6be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04d2171c8cabc817a4f2302905fcd6be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stm_abort_tx</b> (struct stm_tx *tx, int abort_reason)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a473026557b3911a3af8b1b2fc4cc426c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a473026557b3911a3af8b1b2fc4cc426c">stm_load</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr)</td></tr>
<tr class="memdesc:a473026557b3911a3af8b1b2fc4cc426c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactional load.  <a href="#a473026557b3911a3af8b1b2fc4cc426c"></a><br/></td></tr>
<tr class="memitem:a6e03ede10a8c2a6916c1951624e5e569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e03ede10a8c2a6916c1951624e5e569"></a>
<a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stm_load_tx</b> (struct stm_tx *tx, volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5a822c0df0ff5938016674955e7ae99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a5a822c0df0ff5938016674955e7ae99e">stm_store</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value)</td></tr>
<tr class="memdesc:a5a822c0df0ff5938016674955e7ae99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactional store.  <a href="#a5a822c0df0ff5938016674955e7ae99e"></a><br/></td></tr>
<tr class="memitem:a10ac2d0cb36370488d610a4e35c3d6b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10ac2d0cb36370488d610a4e35c3d6b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stm_store_tx</b> (struct stm_tx *tx, volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a77218104875612813d7f2791ac343cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a77218104875612813d7f2791ac343cf6">stm_store2</a> (volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask)</td></tr>
<tr class="memdesc:a77218104875612813d7f2791ac343cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transactional store.  <a href="#a77218104875612813d7f2791ac343cf6"></a><br/></td></tr>
<tr class="memitem:a2ce85896311c382d1ba568567f7c29b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ce85896311c382d1ba568567f7c29b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stm_store2_tx</b> (struct stm_tx *tx, volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5a44485d7970aa1f126e2d1b0106a59c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a5a44485d7970aa1f126e2d1b0106a59c">stm_active</a> (void)</td></tr>
<tr class="memdesc:a5a44485d7970aa1f126e2d1b0106a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current transaction is still active.  <a href="#a5a44485d7970aa1f126e2d1b0106a59c"></a><br/></td></tr>
<tr class="memitem:ad4d29edcd5cbb3a248aaa284781d594e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4d29edcd5cbb3a248aaa284781d594e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stm_active_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32f19f641f5686d363eae18600291030"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a32f19f641f5686d363eae18600291030">stm_aborted</a> (void)</td></tr>
<tr class="memdesc:a32f19f641f5686d363eae18600291030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current transaction has aborted.  <a href="#a32f19f641f5686d363eae18600291030"></a><br/></td></tr>
<tr class="memitem:a915a72d425763e6960c0bc0146b7ab4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a915a72d425763e6960c0bc0146b7ab4d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stm_aborted_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa54f5afae0d6adad8810c332c25cacff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aa54f5afae0d6adad8810c332c25cacff">stm_irrevocable</a> (void)</td></tr>
<tr class="memdesc:aa54f5afae0d6adad8810c332c25cacff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current transaction is still active and in irrevocable state.  <a href="#aa54f5afae0d6adad8810c332c25cacff"></a><br/></td></tr>
<tr class="memitem:aa5a26121754e573c416cb6b97d4828e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a26121754e573c416cb6b97d4828e2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stm_irrevocable_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8db33714565a9fafed0c222181171b41"><td class="memItemLeft" align="right" valign="top">sigjmp_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a8db33714565a9fafed0c222181171b41">stm_get_env</a> (void)</td></tr>
<tr class="memdesc:a8db33714565a9fafed0c222181171b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the environment used by the current thread to jump back upon abort.  <a href="#a8db33714565a9fafed0c222181171b41"></a><br/></td></tr>
<tr class="memitem:a07019f2b74ee5997dc0a819a6bd619af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07019f2b74ee5997dc0a819a6bd619af"></a>
sigjmp_buf *&#160;</td><td class="memItemRight" valign="bottom"><b>stm_get_env_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0094c4f9966306f4a2c8b44a3e79d40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a0094c4f9966306f4a2c8b44a3e79d40d">stm_get_attributes</a> (void)</td></tr>
<tr class="memdesc:a0094c4f9966306f4a2c8b44a3e79d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes associated with the current transactions, if any.  <a href="#a0094c4f9966306f4a2c8b44a3e79d40d"></a><br/></td></tr>
<tr class="memitem:aeae2505582e03b882eed36beff67332f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeae2505582e03b882eed36beff67332f"></a>
<a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stm_get_attributes_tx</b> (struct stm_tx *tx)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaa4e7819e2e3eebec0406555a2ea4502"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aaa4e7819e2e3eebec0406555a2ea4502">stm_get_stats</a> (const char *name, void *val)</td></tr>
<tr class="memdesc:aaa4e7819e2e3eebec0406555a2ea4502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get various statistics about the current thread/transaction.  <a href="#aaa4e7819e2e3eebec0406555a2ea4502"></a><br/></td></tr>
<tr class="memitem:a4c6b2887d013a43530dbb5f54c84ebfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c6b2887d013a43530dbb5f54c84ebfb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stm_get_stats_tx</b> (struct stm_tx *tx, const char *name, void *val)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ca153a890bb4daff693a21897834301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#a9ca153a890bb4daff693a21897834301">stm_set_extension</a> (int enable, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr class="memdesc:a9ca153a890bb4daff693a21897834301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable snapshot extensions for the current transaction, and optionally set an upper bound for the snapshot.  <a href="#a9ca153a890bb4daff693a21897834301"></a><br/></td></tr>
<tr class="memitem:a7af96d5581cb874ac6125145d703dfd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7af96d5581cb874ac6125145d703dfd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stm_set_extension_tx</b> (struct stm_tx *tx, int enable, <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad4fb1a17427e6ad727df28074a646575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ad4fb1a17427e6ad727df28074a646575">stm_set_irrevocable</a> (int serial)</td></tr>
<tr class="memdesc:ad4fb1a17427e6ad727df28074a646575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter irrevocable mode for the current transaction.  <a href="#ad4fb1a17427e6ad727df28074a646575"></a><br/></td></tr>
<tr class="memitem:a8b315f9d146584658ceb37a691c74253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b315f9d146584658ceb37a691c74253"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stm_set_irrevocable_tx</b> (struct stm_tx *tx, int serial)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>STM functions. </p>
<p>This library contains the core functions for programming with STM. </p>
<dl class="section author"><dt>Author</dt><dd>Pascal Felber <a href="#" onclick="location.href='mai'+'lto:'+'pas'+'ca'+'l.f'+'el'+'ber'+'@u'+'nin'+'e.'+'ch'; return false;">pasca<span style="display: none;">.nosp@m.</span>l.fe<span style="display: none;">.nosp@m.</span>lber@<span style="display: none;">.nosp@m.</span>unin<span style="display: none;">.nosp@m.</span>e.ch</a> Patrick Marlier <a href="#" onclick="location.href='mai'+'lto:'+'pat'+'ri'+'ck.'+'ma'+'rli'+'er'+'@un'+'in'+'e.c'+'h'; return false;">patri<span style="display: none;">.nosp@m.</span>ck.m<span style="display: none;">.nosp@m.</span>arlie<span style="display: none;">.nosp@m.</span>r@un<span style="display: none;">.nosp@m.</span>ine.c<span style="display: none;">.nosp@m.</span>h</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2007-2012 </dd></dl>
</div><h2>Typedef Documentation</h2>
<a class="anchor" id="a571736ccf3baeb79b32e66efd03f2ff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a word (accessible atomically) on the target architecture. </p>
<p>The library supports 32-bit and 64-bit architectures. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reason for aborting (returned by sigsetjmp() upon transaction restart). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba33be1ca54eecc0cc8c593d09ed6efbae"></a>STM_PATH_INSTRUMENTED</em>&nbsp;</td><td>
<p>Indicates that the instrumented code path must be executed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba450b54286a2b90acdc9778335990ccec"></a>STM_PATH_UNINSTRUMENTED</em>&nbsp;</td><td>
<p>Indicates that the uninstrumented code path must be executed (serial irrevocable mode). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba7b61a76a11fbf84128a391a9b0cef327"></a>STM_ABORT_EXPLICIT</em>&nbsp;</td><td>
<p>Abort due to explicit call from the programmer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba6c9347782cf0b1d6fea89bc723148551"></a>STM_ABORT_NO_RETRY</em>&nbsp;</td><td>
<p>Abort and no retry due to explicit call from the programmer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba75d0311e7a4ddd3064164e4642d0fa95"></a>STM_ABORT_IMPLICIT</em>&nbsp;</td><td>
<p>Implicit abort (high order bits indicate more detailed reason). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba46eaf37a2b51b4db497304a3e8869973"></a>STM_ABORT_RR_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon reading a memory location being read by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baa0ab09921c0090164a7d6aa2538cac17"></a>STM_ABORT_RW_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon writing a memory location being read by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba4e7abf037faa563495f6fa5da509219c"></a>STM_ABORT_WR_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon reading a memory location being written by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba4d97b7b8272d8d7683ab5a0ffe9c25e7"></a>STM_ABORT_WW_CONFLICT</em>&nbsp;</td><td>
<p>Abort upon writing a memory location being written by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baa705d4540e95c9b214d2dbbebeb7dbe3"></a>STM_ABORT_VAL_READ</em>&nbsp;</td><td>
<p>Abort upon read due to failed validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba30a4997234b15d65d38e27db17f3e93c"></a>STM_ABORT_VAL_WRITE</em>&nbsp;</td><td>
<p>Abort upon write due to failed validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55badb805d9ecf362fe018eeacb14bc7c73e"></a>STM_ABORT_VALIDATE</em>&nbsp;</td><td>
<p>Abort upon commit due to failed validation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba8f6e471602d10189a79ca90ffd4d11e2"></a>STM_ABORT_IRREVOCABLE</em>&nbsp;</td><td>
<p>Abort upon deferring to an irrevocable transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baeb8c86645eef38a461e9ff85c3807c3e"></a>STM_ABORT_KILLED</em>&nbsp;</td><td>
<p>Abort due to being killed by another transaction. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba840c7cb44183d525c2a308071f486670"></a>STM_ABORT_SIGNAL</em>&nbsp;</td><td>
<p>Abort due to receiving a signal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba7b4d1c74aa13aca00f07158f5f3b2091"></a>STM_ABORT_EXTEND_WS</em>&nbsp;</td><td>
<p>Abort due to reaching the write set size limit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba886ebf1c55e78174f2734cf34e699608"></a>STM_ABORT_OTHER</em>&nbsp;</td><td>
<p>Abort due to other reasons (internal to the protocol). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a689d0e2f43d0c823699cd8255ad7bd8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>abort_reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly abort a transaction. </p>
<p>Execution continues at the point where sigsetjmp() has been called after starting the outermost transaction (unless the attributes indicate that the transaction should not retry).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_reason</td><td>Reason for aborting the transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32f19f641f5686d363eae18600291030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_aborted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current transaction has aborted. </p>
<dl class="section return"><dt>Returns</dt><dd>True (non-zero) if the transaction has aborted, false (zero) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a44485d7970aa1f126e2d1b0106a59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_active </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current transaction is still active. </p>
<dl class="section return"><dt>Returns</dt><dd>True (non-zero) if the transaction is active, false (zero) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a34a2ee9e8d2a85b7876580b388c8f274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_commit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to commit a transaction. </p>
<p>If successful, the function returns 1. Otherwise, execution continues at the point where sigsetjmp() has been called after starting the outermost transaction (unless the attributes indicate that the transaction should not retry).</p>
<dl class="section return"><dt>Returns</dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f1e7f7261639257cc8e572cca9010af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_create_specific </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a key to associate application-specific data to the current thread/transaction. </p>
<p>This mechanism can be combined with callbacks to write modules.</p>
<dl class="section return"><dt>Returns</dt><dd>The new key. </dd></dl>

</div>
</div>
<a class="anchor" id="ab934371cd3a4ccff13196df52d118c1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct stm_tx* stm_current_tx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current transaction descriptor. </p>
<p>The library does not require to pass the current transaction as a parameter to the functions (the current transaction is stored in a thread-local variable). One can, however, use the library with explicit transaction parameters. This is useful, for instance, for performance on architectures that do not support TLS or for easier compiler integration. </p>

</div>
</div>
<a class="anchor" id="a67285bbeb06819a4f053207e71ff4995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up the STM library. </p>
<p>This function must be called once, from the main thread, after all transactional threads have completed. </p>

</div>
</div>
<a class="anchor" id="a946305e1b65d3d7eb26c6573a00b7f8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_exit_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up a transactional thread. </p>
<p>This function must be called once from each thread that performs transactional operations, upon exit. </p>

</div>
</div>
<a class="anchor" id="a0094c4f9966306f4a2c8b44a3e79d40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a> stm_get_attributes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get attributes associated with the current transactions, if any. </p>
<p>These attributes were passed as parameters when starting the transaction.</p>
<dl class="section return"><dt>Returns</dt><dd>Attributes associated with the current transaction, or NULL if no attributes were specified when starting the transaction. </dd></dl>

</div>
</div>
<a class="anchor" id="ac94022bd1deed2614d953fa4110bb452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_get_clock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current value of the global clock (used for timestamps). </p>
<p>This function is useful when programming with unit loads and stores.</p>
<dl class="section return"><dt>Returns</dt><dd>Value of the global clock. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db33714565a9fafed0c222181171b41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigjmp_buf* stm_get_env </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the environment used by the current thread to jump back upon abort. </p>
<p>This environment should be used when calling sigsetjmp() before starting the transaction and passed as parameter to <a class="el" href="stm_8h.html#ae984594f360cba2ac5c2abd8875eb0a0" title="Start a transaction.">stm_start()</a>. If the current thread is already executing a transaction, i.e., the new transaction will be nested, the function returns NULL and one should not call sigsetjmp().</p>
<dl class="section return"><dt>Returns</dt><dd>The environment to use for saving the stack context, or NULL if the transaction is nested. </dd></dl>

</div>
</div>
<a class="anchor" id="aac7f1c4dd5f948f23a2f4df0a7d530d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_get_parameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get various parameters of the STM library. </p>
<p>See the source code (stm.c) for a list of supported parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramname">val</td><td>Pointer to the variable that should hold the value of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8b66dbadfd62e541409823d1b80aba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* stm_get_specific </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get application-specific data associated to the current thread/transaction and a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key designating the data to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data stored under the given key. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa4e7819e2e3eebec0406555a2ea4502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_get_stats </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get various statistics about the current thread/transaction. </p>
<p>See the source code (stm.c) for a list of supported statistics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the statistics. </td></tr>
    <tr><td class="paramname">val</td><td>Pointer to the variable that should hold the value of the statistics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a91d8723fd14f8f23f6231f43e5fb0d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the STM library. </p>
<p>This function must be called once, from the main thread, before any access to the other functions of the library. </p>

</div>
</div>
<a class="anchor" id="a7b7d6f423cd3ff074f5c83926fd37439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct stm_tx* stm_init_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a transactional thread. </p>
<p>This function must be called once from each thread that performs transactional operations, before the thread calls any other functions of the library. </p>

</div>
</div>
<a class="anchor" id="aa54f5afae0d6adad8810c332c25cacff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_irrevocable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current transaction is still active and in irrevocable state. </p>
<dl class="section return"><dt>Returns</dt><dd>True (non-zero) if the transaction is active and irrevocable, false (zero) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a473026557b3911a3af8b1b2fc4cc426c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_load </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactional load. </p>
<p>Read the specified memory location in the context of the current transaction and return its value. Upon conflict, the transaction may abort while reading the memory location. Note that the value returned is consistent with respect to previous reads from the same transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read from the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f2aabd7cc97f9a1a340b57aec57fb2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_register </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>on_thread_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>on_thread_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>on_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>on_precommit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>on_commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>on_abort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register application-specific callbacks that are triggered each time particular events occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_thread_init</td><td>Function called upon initialization of a transactional thread. </td></tr>
    <tr><td class="paramname">on_thread_exit</td><td>Function called upon cleanup of a transactional thread. </td></tr>
    <tr><td class="paramname">on_start</td><td>Function called upon start of a transaction. </td></tr>
    <tr><td class="paramname">on_precommit</td><td>Function called before transaction try to commit. </td></tr>
    <tr><td class="paramname">on_commit</td><td>Function called upon successful transaction commit. </td></tr>
    <tr><td class="paramname">on_abort</td><td>Function called upon transaction abort. </td></tr>
    <tr><td class="paramname">arg</td><td>Parameter to be passed to the callback functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the callbacks have been successfully registered, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca153a890bb4daff693a21897834301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_set_extension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable snapshot extensions for the current transaction, and optionally set an upper bound for the snapshot. </p>
<p>This function is useful for implementing efficient algorithms with unit loads and stores while preserving compatibility with with regular transactions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True (non-zero) to enable snapshot extensions, false (zero) to disable them. </td></tr>
    <tr><td class="paramname">timestamp</td><td>If non-null and the timestamp in the referenced variable is smaller than the current upper bound of the snapshot, update the upper bound to the value of the referenced variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4fb1a17427e6ad727df28074a646575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_set_irrevocable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>serial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter irrevocable mode for the current transaction. </p>
<p>If successful, the function returns 1. Otherwise, it aborts and execution continues at the point where sigsetjmp() has been called after starting the outermost transaction (unless the attributes indicate that the transaction should not retry).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>True (non-zero) for serial-irrevocable mode (no transaction can execute concurrently), false for parallel-irrevocable mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abca06bb60ae936118c769f6fdd41530c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_set_parameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set various parameters of the STM library. </p>
<p>See the source code (stm.c) for a list of supported parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the parameter. </td></tr>
    <tr><td class="paramname">val</td><td>Pointer to a variable that holds the new value of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acf336ae279fd83cf1195bd76aea01df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_set_specific </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set application-specific data associated to the current thread/transaction and a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key designating the data to read. </td></tr>
    <tr><td class="paramname">data</td><td>Data to store under the given key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae984594f360cba2ac5c2abd8875eb0a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigjmp_buf* stm_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stm_8h.html#ac9ce435b82936240375ce9e71c27b5db">stm_tx_attr_t</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Specifies optional attributes associated to the transaction. Attributes are copied in transaction-local storage. If null, the transaction uses default attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Environment (stack context) to be used to jump back upon abort. It is the responsibility of the application to call sigsetjmp() immediately after starting the transaction. If the transaction is nested, the function returns NULL and one should not call sigsetjmp() as an abort will restart the top-level transaction (flat nesting). </dd></dl>

</div>
</div>
<a class="anchor" id="a5a822c0df0ff5938016674955e7ae99e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_store </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactional store. </p>
<p>Write a word-sized value to the specified memory location in the context of the current transaction. Upon conflict, the transaction may abort while writing to the memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the memory location. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77218104875612813d7f2791ac343cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_store2 </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transactional store. </p>
<p>Write a value to the specified memory location in the context of the current transaction. The value may be smaller than a word on the target architecture, in which case a mask is used to indicate the bits of the words that must be updated. Upon conflict, the transaction may abort while writing to the memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the memory location. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written. </td></tr>
    <tr><td class="paramname">mask</td><td>Mask specifying the bits to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac932e2cd9b2b1621326d281329362bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_unit_load </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transaction-safe load. </p>
<p>Read the specified memory location outside of the context of any transaction and return its value. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the memory location.</td></tr>
    <tr><td class="paramname">timestamp</td><td>If non-null, the referenced variable is updated to hold the timestamp of the memory location being read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read from the specified address. </dd></dl>

</div>
</div>
<a class="anchor" id="aec9492eba41d0df151c30fc559a14957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_unit_store </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transaction-safe store. </p>
<p>Write a word-sized value to the specified memory location outside of the context of any transaction. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the memory location. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written. </td></tr>
    <tr><td class="paramname">timestamp</td><td>If non-null and the timestamp in the referenced variable is smaller than that of the memory location being written, no data is actually written and the variable is updated to hold the more recent timestamp. If non-null and the timestamp in the referenced variable is not smaller than that of the memory location being written, the memory location is written and the variable is updated to hold the new timestamp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if value has been written, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a328faa38ec6bf579ba6fd166765a7527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_unit_store2 </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#a571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transaction-safe store. </p>
<p>Write a value to the specified memory location outside of the context of any transaction. The value may be smaller than a word on the target architecture, in which case a mask is used to indicate the bits of the words that must be updated. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the memory location. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written. </td></tr>
    <tr><td class="paramname">mask</td><td>Mask specifying the bits to be written. </td></tr>
    <tr><td class="paramname">timestamp</td><td>If non-null and the timestamp in the referenced variable is smaller than that of the memory location being written, no data is actually written and the variable is updated to hold the more recent timestamp. If non-null and the timestamp in the referenced variable is not smaller than that of the memory location being written, the memory location is written and the variable is updated to hold the new timestamp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if value has been written, 0 otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 29 2013 14:30:49 for TinySTM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
